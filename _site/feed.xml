<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-04-20T11:03:43+08:00</updated><id>/</id><title type="html">DSL’Blog</title><subtitle>我叫董诗磊,我就是一码农.欢迎来到我的博客</subtitle><entry><title type="html">2017-04-11 语录</title><link href="/morning-saying0411/" rel="alternate" type="text/html" title="2017-04-11 语录" /><published>2017-04-11T00:00:00+08:00</published><updated>2017-04-11T00:00:00+08:00</updated><id>/morning-saying0411</id><content type="html" xml:base="/morning-saying0411/">&lt;h1 id=&quot;2017-04-11-语录&quot;&gt;2017-04-11 语录&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;人要有一颗干净的心无论相貌无论着装心的通透是最美的不分贫富不分高低心的善良是最贵的身处俗世却不被俗世所染笑在脸上笑也在心上对人几分真便会换取几分心用情几多诚就会收获几多永恒眼睛纯净才能看见美丽的风景心灵干净才能拥有纯粹的感情一个人的心就是一个人的世界&quot;&gt;人，要有一颗干净的心。无论相貌，无论着装，心的通透是最美的。不分贫富，不分高低，心的善良是最贵的。身处俗世，却不被俗世所染。笑在脸上，笑也在心上。对人几分真，便会换取几分心。用情几多诚，就会收获几多永恒。眼睛纯净，才能看见美丽的风景。心灵干净，才能拥有纯粹的感情。一个人的心，就是一个人的世界。&lt;/h2&gt;

&lt;h2 id=&quot;美好的一天从自然开始&quot;&gt;美好的一天从自然开始！&lt;/h2&gt;</content><summary type="html">2017-04-11 语录</summary></entry><entry><title type="html">2017-04-08 语录</title><link href="/morning-saying0408/" rel="alternate" type="text/html" title="2017-04-08 语录" /><published>2017-04-08T00:00:00+08:00</published><updated>2017-04-08T00:00:00+08:00</updated><id>/morning-saying0408</id><content type="html" xml:base="/morning-saying0408/">&lt;h1 id=&quot;2017-04-08-语录&quot;&gt;2017-04-08 语录&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;总觉得自己还在过程中在一个需要时间来等待运气积累经历磨练的这个过程中大部分时间里面看到一些人们真实地活在我对生活的想象中的确是会偷偷地深深地羡慕也偶尔会掉入反复无常的自卑和失望里面但是始终内心深处存有希望也相信这些都只是过程同时也相信那些想象的成真我都值得&quot;&gt;总觉得自己还在过程中，在一个需要时间来等待、运气积累、经历磨练的这个过程中。大部分时间里面看到一些人们真实地活在我对生活的想象中，的确是会偷偷地，深深地羡慕。也偶尔会掉入反复无常的自卑和失望里面。但是始终，内心深处存有希望，也相信这些都只是过程，同时也相信那些想象的成真，我都值得。&lt;/h2&gt;

&lt;h2 id=&quot;美好的一天从自然开始&quot;&gt;美好的一天从自然开始！&lt;/h2&gt;</content><summary type="html">2017-04-08 语录</summary></entry><entry><title type="html">2017-04-05 语录</title><link href="/morning-saying/" rel="alternate" type="text/html" title="2017-04-05 语录" /><published>2017-04-05T00:00:00+08:00</published><updated>2017-04-05T00:00:00+08:00</updated><id>/morning-saying</id><content type="html" xml:base="/morning-saying/">&lt;h1 id=&quot;2017-04-05-语录&quot;&gt;2017-04-05 语录&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;身安不如心安屋宽不如心宽以自然之道养自然之身以喜悦之身养喜悦之神有所畏惧是做人最基本的良心准则所谓快乐不是财富多而是欲望少做人人品为先才能为次做事明理为先勤奋为次人生要学会不抱怨不等待不盲从&quot;&gt;身安，不如心安；屋宽，不如心宽。以自然之道，养自然之身；以喜悦之身，养喜悦之神。有所畏惧，是做人最基本的良心准则。所谓快乐，不是财富多而是欲望少。做人，人品为先，才能为次；做事，明理为先，勤奋为次。人生要学会不抱怨，不等待，不盲从。&lt;/h2&gt;

&lt;h2 id=&quot;美好的一天从自然开始&quot;&gt;美好的一天从自然开始！&lt;/h2&gt;

&lt;h1 id=&quot;2017-04-13&quot;&gt;2017-04-13&lt;/h1&gt;

&lt;h2 id=&quot;老子说知人者智自知者明胜人者有力自胜者强一个人能了解别人慧眼识人是聪明人但能够认识自己了解自己的人才是真正有智慧的人能够战胜别人的是有力量的勇士但能够战胜自己的人才是真正的强者&quot;&gt;老子说：”知人者智，自知者明，胜人者有力，自胜者强。”一个人，能了解别人，慧眼识人，是聪明人，但能够认识自己、了解自己的人，才是真正有智慧的人；能够战胜别人的，是有力量的勇士，但能够战胜自己的人，才是真正的强者！&lt;/h2&gt;</content><summary type="html">2017-04-05 语录</summary></entry><entry><title type="html">iOS沙盒文件处理</title><link href="/sand-box/" rel="alternate" type="text/html" title="iOS沙盒文件处理" /><published>2017-04-02T11:59:21+08:00</published><updated>2017-04-02T11:59:21+08:00</updated><id>/sand-box</id><content type="html" xml:base="/sand-box/">&lt;p&gt;我最近在做项目的时候会用到关于沙盒的处理，以下是常用的操作：&lt;/p&gt;

&lt;h3 id=&quot;1-文件写入操作&quot;&gt;1. 文件写入操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#pragma mark文件写入操作

-(void)writeImageFileToDocument {

//声明一个文件管理器

NSFileManager*manger = [NSFileManagerdefaultManager];

//获取沙盒路径

NSString* writePath = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents&quot;];

//文件路径

NSString*imagePath=[writePathstringByAppendingPathComponent:@&quot;DSL.jpg&quot;];

if([mangerfileExistsAtPath:imagePath]) {

NSLog(@&quot; image is exist&quot;);

return;

}
//将图片写到沙盒中

NSString*sourcePath = [[NSBundlemainBundle]pathForResource:@&quot;1.jpg&quot;ofType:nil];

NSData*iamgeData = [NSDatadataWithContentsOfFile:sourcePath];

if([iamgeDatawriteToFile:imagePathatomically:YES]) {

NSLog(@&quot;write image success&quot;);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2文件读取操作&quot;&gt;2.文件读取操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#pragma mark文件读取操作

- (void)readImageFileFromDocument{

//获取路径

NSString* imagePath = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents/DSL.jpg&quot;];

//显示

self.successImage.image= [UIImageimageWithContentsOfFile:imagePath];

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3删除文件操作&quot;&gt;3.删除文件操作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#pragma mark删除文件操作

- (void)deleteDocument{

//获取路径

NSString* imagePath = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents/DSL.jpg&quot;];

NSFileManager*manger = [NSFileManagerdefaultManager];

NSError* error;

[mangerremoveItemAtPath:imagePatherror:&amp;amp;error];

if(error) {

NSLog(@&quot;delete error == %@&quot;,[errorlocalizedDescription]);

}else{

NSLog(@&quot; delete success&quot;);

}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3在沙盒中新建一个文件夹&quot;&gt;3.在沙盒中新建一个文件夹&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;
#pragma mark在沙盒中新建一个文件夹

- (void)createFilder

{

//沙盒文件的路径

NSString* documentStr = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents&quot;];

//新的文件的路径

NSString* newFilderPath = [documentStrstringByAppendingPathComponent:@&quot;/DSLFilder&quot;];

NSFileManager* manger = [NSFileManagerdefaultManager];

NSError* error;

//创建操作

[mangercreateDirectoryAtPath:newFilderPathwithIntermediateDirectories:YESattributes:nilerror:&amp;amp;error];

if(error) {

NSLog(@&quot;create filder failed == %@&quot;,[errorlocalizedDescription]);

}else{

NSLog(@&quot;create filder success&quot;);

}

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4给新建的文件写入一个张图片&quot;&gt;4.给新建的文件写入一个张图片&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#pragma mark给新建的文件写入一个张图片

- (void)writeImageToNewFilder{

//新的文件的路径

NSString* documentStr = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents/DSLFilder/DSL.jpg&quot;];

//将图片写到沙盒中

NSString*sourcePath = [[NSBundlemainBundle]pathForResource:@&quot;1.jpg&quot;ofType:nil];

NSError* error;

[[NSFileManagerdefaultManager]copyItemAtPath:sourcePathtoPath:documentStrerror:&amp;amp;error];

//这里用copy

if(error) {

NSLog(@&quot;write image failed==%@&quot;,[errorlocalizedDescription]);

}else{

NSLog(@&quot;write image success&quot;);

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;5获取某个目录下的所有文件名&quot;&gt;5.获取某个目录下的所有文件名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#pragma mark获取某个目录下的所有文件名

- (void)getAllDocumentName{

//获取需要查找的路径

NSString* documentPath = [NSHomeDirectory()stringByAppendingPathComponent:@&quot;/Documents/DSLFilder&quot;];

NSArray* namesArray =nil;

NSError* error;

namesArray = [[NSFileManagerdefaultManager]contentsOfDirectoryAtPath:documentPatherror:&amp;amp;error];

if(error) {

}else

{

[namesArrayenumerateObjectsUsingBlock:^(id_Nonnullobj,NSUIntegeridx,BOOL*_Nonnullstop) {

if([objhasSuffix:@&quot;jpg&quot;]) {

NSLog(@&quot;=====%@&quot;,obj);

}

}];

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dslcoding/sandboxDealWith&quot;&gt;相关demo&lt;/a&gt;
没啦，结束啦&lt;/p&gt;</content><summary type="html">我最近在做项目的时候会用到关于沙盒的处理，以下是常用的操作：</summary></entry><entry><title type="html">iOS随手记(一)</title><link href="/iOS-note1/" rel="alternate" type="text/html" title="iOS随手记(一)" /><published>2017-04-02T11:59:21+08:00</published><updated>2017-04-02T11:59:21+08:00</updated><id>/iOS-note1</id><content type="html" xml:base="/iOS-note1/">&lt;h1 id=&quot;开发随手记一&quot;&gt;开发随手记(一)&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1关于给tabbaritem设置属性&quot;&gt;1.关于给tabbarItem设置属性&lt;/h2&gt;
&lt;h3 id=&quot;11设置图片&quot;&gt;1.1设置图片&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;childController.tabBarItem.image= [normalImageimageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];

childController.tabBarItem.selectedImage= [selectedImageimageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;12未选中字体颜色&quot;&gt;1.2未选中字体颜色&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;[[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName:unselectColor,NSFontAttributeName:[UIFont fontWithName:foneName size:15]} forState:UIControlStateNormal];

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;13选中字体颜色&quot;&gt;1.3选中字体颜色&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;[[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName:selectColor,NSFontAttributeName:[UIFont fontWithName:foneName size:15]} forState:UIControlStateSelected];

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2之前在做项目的时候在push界面的时候总是发现有灰色的阴影在网上查了资料在知道&quot;&gt;2.之前在做项目的时候在push界面的时候总是发现有灰色的阴影。在网上查了资料在知道&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;自从iOS7之后push导航栏出现白色阴影，导航栏的背景色是透明的，或者是黑色阴影估计就是底层Controller的背景色的解决方法是
self.window.backgroundColor = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;3关于通知的注意事项&quot;&gt;3.关于通知的注意事项&lt;/h2&gt;

&lt;p&gt;###3.1在主线程上发送通知&lt;/p&gt;

&lt;p&gt;###3.2注册通知和移除通知一定要成对出现，比如在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;//一定要成对出现，避免出现bug
- (void)viewWillAppear:(BOOL)animated

{

[super viewWillAppear:animated];

[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(NSNotificationCenterAction) name:@&quot;NSNotificationCenter&quot;object:nil];

}

- (void)viewWillDisappear:(BOOL)animated

{

[super viewWillDisappear:animated];

[[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;NSNotificationCenter&quot;object:nil];

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;33在通知移除的时候不要使用&quot;&gt;3.3在通知移除的时候。不要使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;[[NSNotificationCenter defaultCenter] removeObserver:self]
因为上面那个方法可能会把系统注册的通知也给移除了，不要这样操纵，一旦出现bug。不容易发现。正确的移除方式是
[[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;NSNotificationCenter&quot;object:nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4获取文件的扩展名&quot;&gt;4.获取文件的扩展名&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;NSString *str  = @&quot;DSL.mp4&quot;;

BOOL isMp4 = [str hasSuffix:@&quot;.mp4&quot;];

//拿到字符串扩展名

NSString *extension = [str pathExtension];

if ([extension isEqualToString:@&quot;mp4&quot;]) {

NSLog(@&quot;我是MP4&quot;);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.获取cell上的控件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)digAction:(UIButton*)btn event:(id)event

{

NSSet*touches =[eventallTouches];

UITouch*touch =[touchesanyObject];

CGPointcurrentTouchPosition = [touchlocationInView:_tableView];

NSIndexPath*indexPath= [_tableViewindexPathForRowAtPoint:currentTouchPosition];

//通过这个index获取cell

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本篇结束了。。。&lt;/p&gt;</content><summary type="html">开发随手记(一)</summary></entry><entry><title type="html">iOSExtensionProgram总结</title><link href="/iOSExtension/" rel="alternate" type="text/html" title="iOSExtensionProgram总结" /><published>2017-04-01T11:59:21+08:00</published><updated>2017-04-01T11:59:21+08:00</updated><id>/iOSExtension</id><content type="html" xml:base="/iOSExtension/">&lt;h1 id=&quot;iosextensionprogram总结&quot;&gt;iOSExtensionProgram总结&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1上架的问题hostapp和containingapp的版本号必须一致&quot;&gt;1.上架的问题hostapp和containingapp的版本号必须一致，&lt;/h3&gt;

&lt;h3 id=&quot;2关于bundle-identifier的话hostapp-和-containingapp都是独立的app所有你必须申请两个id&quot;&gt;2.关于Bundle identifier的话，hostapp 和 containingapp都是独立的App。所有你必须申请两个ID，&lt;/h3&gt;

&lt;h3 id=&quot;3上面的第二条是申请两个bundle-identifier这个两个bundle-identifier的名字规则是hostappcomdslcontainingappcomdsltodaywight通知扩展还有键盘扩展comdslkeyboard&quot;&gt;3.上面的第二条是申请两个Bundle identifier。这个两个Bundle identifier的名字规则是：hostApp:com.DSL，containingapp:com.DSL.todayWight(通知扩展，还有键盘扩展com.DSL.keyboard)&lt;/h3&gt;

&lt;h3 id=&quot;4关于cocoapods的使用请看我的写的一篇ios-keyboarded-extension&quot;&gt;4.关于cocoapods的使用,请看我的写的一篇iOS Keyboarded Extension&lt;/h3&gt;

&lt;h3 id=&quot;5别的问题遇见在说吧&quot;&gt;5.别的问题遇见在说吧&lt;/h3&gt;</content><summary type="html">iOSExtensionProgram总结</summary></entry><entry><title type="html">关于Keyboard Extension</title><link href="/keyboarded/" rel="alternate" type="text/html" title="关于Keyboard Extension" /><published>2017-04-01T11:59:21+08:00</published><updated>2017-04-01T11:59:21+08:00</updated><id>/keyboarded</id><content type="html" xml:base="/keyboarded/">&lt;h1 id=&quot;关于keyboard-extension&quot;&gt;关于Keyboard Extension&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;写了好几天的keyboarded extension， 说实话这个Extension 有点恶心。我感觉bug挺多的，也不能这样说，可能不经常出现的bug都让我遇到了。下面开始说我遇到到了那些问题，以及是怎么做的。&lt;/p&gt;

&lt;p&gt;声明：本文章不做文档翻译，想看翻译自行查询.(网上的都是翻译不解决实际问题。我已经。。。。) &lt;a href=&quot;http://www.jianshu.com/p/987dfa9f3baf&quot;&gt;键盘扩展翻译&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-代码分享hostapp-与containapp代码分享和todayextortion-是一样的这里不做多说-todayextortion&quot;&gt;1 代码分享。hostApp 与containApp代码分享和TodayExtortion 是一样的。这里不做多说 &lt;a href=&quot;https://dslcoding.github.io/Today-Extension/&quot;&gt;TodayExtortion&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;2数据共享hostapp-与containapp代码分享和todayextortion-是一样的不做多说-todayextortion&quot;&gt;2数据共享。hostApp 与containApp代码分享和TodayExtortion 是一样的。不做多说 &lt;a href=&quot;https://dslcoding.github.io/Today-Extension/&quot;&gt;TodayExtortion&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;3申请idhostapp-与containapp代码分享和todayextortion-是一样的不做多说todayextortion&quot;&gt;3申请ID。hostApp 与containApp代码分享和TodayExtortion 是一样的。不做多说&lt;a href=&quot;https://dslcoding.github.io/Today-Extension/&quot;&gt;TodayExtortion&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;以上都是共同点，毕竟都是扩展。&lt;/p&gt;

&lt;p&gt;下面我认为是重点(因为我是吃过亏的)：&lt;/p&gt;

&lt;h3 id=&quot;1关于在扩展中使用cocoapods这个会者不难难者恶心&quot;&gt;1.关于在扩展中使用cocoapods，这个会者不难，难者恶心。&lt;/h3&gt;
&lt;p&gt;首先先看stackoverflow&lt;a href=&quot;http://stackoverflow.com/questions/37280077/error-with-cocoapods-link-with-after-update-to-1-0-0&quot;&gt;Extension cocoapods&lt;/a&gt;这个是我在扩展中使用cocoapads出现问题在stackoverflow中找到的目前我找的最佳答案。如果谁知道更好的方法，给我也说说。按照这个上面的说的直接就可以用在hostApp与containApp分别导入相应库就可以了。
&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/5adbe79572ebbc69b073.png&quot; alt=&quot;&quot; /&gt;
主意：提示框如果要是使用第三方的话 ，(算了还是别用第三放了，因为第三方的有sharedApplication，在扩展中获取不到sharedApplication对象)，一定主意。当你按照上面的内容 pod install 成功的时候，你会发现在项目中的hostApp 与containApp中使用的一些库的头文件报错，意思是找不到相应的文件，遇到这种情况，别着急。因为不添加这个use_frameworks!，cocoapads是用static libraries 管理代码的，如果是使的话，cocoapads则是用framework的形式管理代码。所以你必须分别到hostApp 与containApp 中的Target中的BuildPhases 中的 Linked Framework and Libraries 添加相应的第三库，运行一下，顺利通过。这个cocoapds就到此为止。&lt;/p&gt;
&lt;h3 id=&quot;2关于键盘的高度&quot;&gt;2.关于键盘的高度&lt;/h3&gt;
&lt;p&gt;我测试过，讯飞的键盘的高度大概在280左右。于是我也是280.但是我发现一个问题。我的手机是iOS9，但是按照官方文档的自定义高度的方法，不起作用，我在iOS10就可以。于是我🈶️去stackoverflow转了一下，找到了这个。就顺利解决了&lt;a href=&quot;http://stackoverflow.com/questions/36145450/incorrect-keyboard-extension-height-after-rotation&quot;&gt;自定义键盘高度&lt;/a&gt;。我写在viewdidload里面。就是加载不出来。哎。。。&lt;/p&gt;
&lt;h3 id=&quot;3切换输入法&quot;&gt;3.切换输入法&lt;/h3&gt;
&lt;p&gt;官方文档明确表示，没有给用户切换下个输入法的第三方键盘是不会过审核的。大家主意安全。我一开始就用的是这个方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)handleInputModeListFromView:(nonnull UIView *)view withEvent:(nonnull UIEvent *)event NS_AVAILABLE_IOS(10_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在iOS10上面用的挺爽的。到iOS9上怎么测试就是行。后来看看那个只是针对iOS10 的，尴尬。用这个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt; //iOS9 和iOS10都是可以的。可以试试
  - (void)advanceToNextInputMode;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4推荐一些第三方的&quot;&gt;4.推荐一些第三方的。&lt;/h3&gt;
&lt;p&gt;keyboard &lt;a href=&quot;https://github.com/polishedcode/tasty-imitation-keyboard&quot;&gt;Extension第三方&lt;/a&gt;。这个自定义键盘其实也不太难。他是一个控制器 UIInputViewController继承自UIViewController，说白就是一个控制器，除了不能获取sharedApplication对象，别的还可以。还有就是坐标的问题，要主意一下。每个人都有获取坐标的习惯不一样，比如我是这样的self.view.frame.size.with。这个在扩展中是不能获取到的。主意。&lt;/p&gt;

&lt;h3 id=&quot;5记得把requestsopenaccess设置为yes&quot;&gt;5.记得把RequestsOpenAccess设置为YES。&lt;/h3&gt;

&lt;h3 id=&quot;6至今未解决的问题&quot;&gt;6.至今未解决的问题。&lt;/h3&gt;
&lt;p&gt;请求帮助 我的需求是扩展键盘上放了一个uicollectview。每个cell上都加载一个图片。获取图片的步骤：从网络上请求，转化data在转成base64，生成base64字符串。存到数据库。显示的时候，将base64字符串转成data 在转成image；每个图片大概有1Mgif动图吧。不知掉哪个环节出现问题。以至于总是报如下的两个错误。(后来我用工具检测发现内存蹦了600M，用的SDWebimage加载的)。后来用了各种的方法解决也没解决成功就放弃了。&lt;/p&gt;

&lt;h3 id=&quot;61遇见的插件中断和服务中断下面是服务中断的错误信息&quot;&gt;6.1遇见的插件中断和服务中断。下面是服务中断的错误信息&lt;/h3&gt;

&lt;p&gt;2017-03-24 21:37:45.820834 ExpressionBaby[3672:934876] viewServiceDidTerminateWithError:: Error Domain=_UIViewServiceInterfaceErrorDomain Code=3 “(null)” UserInfo={Message=Service Connection Interrupted} 2017-03-24 21:37:48.709876 ExpressionBaby[3672:934876] [App] if we’re in the real pre-commit handler we can’t actually add any new fences due to CA restriction 2017-03-24 21:37:49.222492 ExpressionBaby[3672:934876] viewServiceDidTerminateWithError:: Error Domain=_UIViewServiceInterfaceErrorDomain Code=3 “(null)” UserInfo={Message=Service Connection Interrupted} 2017-03-24 21:37:51.231664 ExpressionBaby[3672:934876] viewServiceDidTerminateWithError:: Error Domain=_UIViewServiceInterfaceErrorDomain Code=3 “(null)” UserInfo={Message=Service Connection Interrupted} 2017-03-24 21:37:53.225378 ExpressionBaby[3672:934876] [App] if we’re in the real pre-commit handler we can’t actually add any new fences due to CA restriction 2017-03-24 21:37:54.500931 ExpressionBaby[3672:934876] [App] if we’re in the real pre-commit handler we can’t actually add any new fences due to CA restriction 2017-03-24 21:37:55.016598 ExpressionBaby[3672:934876] viewServiceDidTerminateWithError:: Error Domain=_UIViewServiceInterfaceErrorDomain Code=3 “(null)” UserInfo={Message=Service Connection Interrupted}&lt;/p&gt;
&lt;h3 id=&quot;61-上架补充上架的时候一定要有数字和英文键盘另一个是协议必须要有的&quot;&gt;6.1 上架补充，上架的时候一定要有数字和英文键盘,另一个是协议必须要有的，&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/7b86d88e2a3da8847506.png&quot; alt=&quot;&quot; /&gt;&lt;/h3&gt;
&lt;p&gt;协议内容就是关于用户的隐私什么的,大概内容就是要保护用户的隐私.(必须要写的)&lt;/p&gt;
&lt;h3 id=&quot;62还有其他的一些坑转载子剑尖的博客&quot;&gt;6.2还有其他的一些坑&lt;a href=&quot;http://www.cnblogs.com/YungMing/p/5093307.html&quot;&gt;转载子剑尖的博客&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我叫董诗磊我就是一码农。&lt;/p&gt;</content><summary type="html">关于Keyboard Extension</summary></entry><entry><title type="html">内存管理</title><link href="/iOS-Memory/" rel="alternate" type="text/html" title="内存管理" /><published>2017-04-01T11:59:21+08:00</published><updated>2017-04-01T11:59:21+08:00</updated><id>/iOS-Memory</id><content type="html" xml:base="/iOS-Memory/">&lt;h1 id=&quot;内存管理&quot;&gt;内存管理&lt;/h1&gt;

&lt;hr /&gt;
&lt;p&gt;今天花啦点时间了解一些自动释放池@autoreleasepool
先说说ARC是啥。我的理解是。ARC是苹果公司在iOS5出现的。并在xcode4.2使用的。虽然没有经历过MRC的时代，但是我也做了一些了解。做个记录.
&lt;!-- ### 在MRC时代如果用刀alloc，new，copy这些关键字。都需要使用release来释放。而autorelease是把对象放到内存池里，autoreleasepool释放的时候，该对想也跟着释放了。另外还有一个关键字是retain这个是将该对象的引用计数加1. --&gt;&lt;/p&gt;
&lt;h3 id=&quot;arc是采用引用计数的管理基于编译器的机制来管理内存的这样的话开发人员不用手动添加releaseautorelease是编译器在编译的时候在合适的地方加入releaseautorelease只要没有强指针引用就被释放了这样就大大方便了开发人员而且在某种程度来说也是一种优化编译速度更快&quot;&gt;ARC是采用引用计数的管理，基于编译器的机制来管理内存的。这样的话，开发人员不用手动添加release，autorelease。是编译器在编译的时候，在合适的地方加入release，autorelease。只要没有强指针引用就被释放了。这样就大大方便了开发人员。而且在某种程度来说也是一种优化。编译速度更快。&lt;/h3&gt;

&lt;h2 id=&quot;在mrc的autoreleasepool&quot;&gt;在MRC的@autoreleasepool&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;NSAutoreleasePool *DSLpool = [[NSAutoreleasePool alloc] init];

NSString* DSLStr = [[[NSString alloc] initWithString:@&quot;tutuge&quot;] autorelease];
// DSLStr...

[pool release];

//DSLStr release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面表达的意思是对象创建完之后顺便在发送一个autorelease的消息，然后NSAutoreleasePool结束的时候就释放了。&lt;/p&gt;

&lt;h2 id=&quot;在arc的autoreleasepool&quot;&gt;在ARC的@autoreleasepool&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;NSArray *urls = &amp;lt;# An array of file URLs #&amp;gt;;
for (NSURL *url in urls) {
 
    @autoreleasepool {
        NSError *error;
        NSString *fileContents = [NSString stringWithContentsOfURL:url
                                         encoding:NSUTF8StringEncoding error:&amp;amp;error];
        /* Process the string, creating and autoreleasing more objects. */
    }
}
//把相关执行的demo放到@autoreleasepool{}中。因为在ARC中我们不用给对象发送autorelease对象，编译器在编译的时候帮我们添加了，是不是很方便。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html&quot;&gt;苹果的官方文档&lt;/a&gt;在以下几种情况下使用@autoreleasepool：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;写命令行程序，没有UI界面&lt;/li&gt;
  &lt;li&gt;常见大量的临时对象&lt;/li&gt;
  &lt;li&gt;创建新的线程(非Cocoa程序创建的线程)&lt;/li&gt;
  &lt;li&gt;长时间在后台的任务
上面的实例就是用到了@autoreleasepool的循环，创建大量的临时对象。利用@autorelease可以及时对内存进行释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没有啦，完啦&lt;/p&gt;</content><summary type="html">内存管理</summary></entry><entry><title type="html">使用类别(Category)和扩展(Extension)</title><link href="/Category-Extension/" rel="alternate" type="text/html" title="使用类别(Category)和扩展(Extension)" /><published>2017-04-01T11:59:21+08:00</published><updated>2017-04-01T11:59:21+08:00</updated><id>/Category-Extension</id><content type="html" xml:base="/Category-Extension/">&lt;h1 id=&quot;使用类别category和扩展extension&quot;&gt;使用类别(Category)和扩展(Extension)&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1类别&quot;&gt;1.类别&lt;/h1&gt;
&lt;h3 id=&quot;先建立一个类别项目我这里就直接给vc加一个类别名字是nslog记得选category而且category是有m文件的&quot;&gt;先建立一个类别项目，我这里就直接给VC加一个类别。名字是NSLog。记得选Category，而且Category是有.m文件的。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/b76a58836532443c945d.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/4171593997bcac5e30eb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;1先测试&quot;&gt;1.先测试：&lt;/h1&gt;
&lt;h2 id=&quot;11添加方法&quot;&gt;1.1添加方法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;//先在.h文件中添加一个方法
- (void)printStr:(NSString*)str;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;@implementationViewController (NSLog)

//在.m中实现

- (void)printStr:(NSString*)str

{

NSLog(@&quot;====print==%@&quot;,str);

}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;//在VC中调用类别的方法,运行

//[self printStr:@&quot;我叫董诗磊,我就是一码农&quot;];

//成功输出
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;12添加属性&quot;&gt;1.2添加属性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;@interfaceViewController (NSLog)

//在没有使用runtim建立关联引用建立的字符串

@property(nonatomic,copy)NSString* dsl;

////先添加一个方法

//- (void)printStr:(NSString *)str;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;//在VC中做赋值操作，，，，，然后成功崩溃，

self.dsl=@&quot;我叫董诗磊,我就是一码农&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;崩溃的原因
&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/8364ed8677d3c03fa6af.png&quot; alt=&quot;&quot; /&gt;
不识别set方法。这里就可以说明是可以添加属性，但是不会自动生成get,set方法。不过这里可以使用runtime建立关联。
如果有这方面的需求可以用runtime具体的下面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;导入头文件#import &amp;lt;objc/runtime.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;.h

@interfaceViewController (NSLog)

//声明属性

@property(nonatomic,copy)NSString* dsl;

@end

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;.m

static NSString*dslKEY =@&quot;dslKEY&quot;;

@implementationViewController (NSLog)

- (void)printStr:(NSString*)str

{

NSLog(@&quot;====print==%@&quot;,str);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;.m

- (void)setDsl:(NSString*)dsl

{

//四个参数原对象，关联时的用来标记的是哪个属性key(可能要添加多个属性)

objc_setAssociatedObject(self, &amp;amp;dslKEY, dsl,OBJC_ASSOCIATION_COPY);

}
- (NSString*)dsl

{

returnobjc_getAssociatedObject(self,&amp;amp;dslKEY);

}
//在VC中测试输出字符串字符串

self.dsl=@&quot;我叫董诗磊,我就是一码农&quot;;

NSLog(@&quot;====use runtime ===%@&quot;,self.dsl);

成功输出
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上都是Category添加属性和方法
我的理解是：&lt;/p&gt;

&lt;h1 id=&quot;11类别就是扩展类可以添加方法不能添加成员变量&quot;&gt;1.1类别就是扩展类可以添加方法。不能添加成员变量。&lt;/h1&gt;

&lt;h3 id=&quot;12如果添加property的话编译是没有问题但是运行的时候就会报错的也可以用runtime来关联引用实现添加属性&quot;&gt;1.2如果添加@property的话编译是没有问题。但是运行的时候就会报错的。也可以用runtime来关联引用实现添加属性。&lt;/h3&gt;

&lt;h3 id=&quot;13如果类别的方法和原类的方法名重复的话优先调用类别的方法原类的犯法会忽略尽量别这样&quot;&gt;1.3如果类别的方法和原类的方法名重复的话，优先调用类别的方法。原类的犯法会忽略。尽量别这样&lt;/h3&gt;

&lt;h3 id=&quot;14继承和类别&quot;&gt;1.4继承和类别&lt;/h3&gt;

&lt;h3 id=&quot;141关于继承和类别我的理解是如果这个类有很多子类的时候只需要扩展这个类不影响到原有的代码继承较好要是紧紧扩展方法的话分类更好&quot;&gt;1.4.1关于继承和类别我的理解是如果这个类有很多子类的时候，只需要扩展这个类不影响到原有的代码继承较好，要是紧紧扩展方法的话，分类更好。&lt;/h3&gt;
&lt;h3 id=&quot;142类别主要是针对系统提供的一些类系统本身是不提供继承去扩展方法的继承子类继承父类而类别不能扩展属性runtime可以方法也不能重复一旦重复就会替换原有的方法没了&quot;&gt;1.4.2类别主要是针对系统提供的一些类，系统本身是不提供继承去扩展方法的。继承子类继承父类，而类别不能扩展属性(runtime可以)，方法也不能重复，一旦重复。就会替换原有的方法。没了&lt;/h3&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;2扩展&quot;&gt;2.扩展&lt;/h1&gt;

&lt;h1 id=&quot;扩展是类别的一种特例也是匿名类可以声明属性和方法声明的方法要实现&quot;&gt;扩展是类别的一种特例。也是匿名类，可以声明属性和方法，声明的方法要实现&lt;/h1&gt;

&lt;h3 id=&quot;21先测试给vc加extension&quot;&gt;2.1先测试给VC加Extension&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/8fe3dce41b2b974be9fd.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/55f2357045a9e0e3a59b.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现方法1就是上面的那一种建立一个extensionh文件然后声明&quot;&gt;实现方法1.就是上面的那一种，建立一个Extension.h文件然后声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#import&quot;ViewController.h&quot;

@interfaceViewController ()

@property(nonatomic,copy) NSString * vcExten;

- (void)test;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)viewDidLoad {

[self test];

//扩展在ViewDidLoad里面实现并调试

self.vcExten=@&quot;exten&quot;;

NSLog(@&quot;====use exten ==%@&quot;,self.vcExten);

}

- (void)test

{

NSLog(@&quot;extension===&quot;);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;实现方法2就是上面的那一种建立一个extensionh文件然后声明&quot;&gt;实现方法2.就是上面的那一种，建立一个Extension.h文件然后声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;#import&quot;ViewController.h&quot;

#import&quot;ViewController+NSLog.h&quot;

#import&quot;ViewController_VCExten.h&quot;

这个@interface ......@end本身就是扩展

@interfaceViewController()

@end

@implementationViewController

- (void)viewDidLoad {

[superviewDidLoad];



}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dslcoding/Category-Extension&quot;&gt;相关demo&lt;/a&gt;&lt;/p&gt;</content><summary type="html">使用类别(Category)和扩展(Extension)</summary></entry><entry><title type="html">开发随手记(二)</title><link href="/iOS-note2/" rel="alternate" type="text/html" title="开发随手记(二)" /><published>2017-04-01T11:59:21+08:00</published><updated>2017-04-01T11:59:21+08:00</updated><id>/iOS-note2</id><content type="html" xml:base="/iOS-note2/">&lt;h1 id=&quot;开发随手记二&quot;&gt;开发随手记(二)&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;在项目中积累中的错误&quot;&gt;在项目中积累中的错误&lt;/h1&gt;

&lt;p&gt;1.ld: can’t link with a main executable file ‘/Users/apple/Library/Developer/Xcode/DerivedData/LePaiDemo-ftsuwgzvjdjwzghgkuefbzvdkvey/Build/Products/Debug-iphoneos/LePaiDemo.app/LePaiDemo’ for architecture armv7clang: error: unable to execute command: Segmentation fault: 11clang: error: linker command failed due to signal (use -v to see invocation)
  &lt;img src=&quot;http://ac-l1vX02tC.clouddn.com/32763884c73603e8276e.png&quot; alt=&quot;&quot; /&gt;
    把Architectures的debug改为NO就可以&lt;/p&gt;

&lt;p&gt;2.Code Sign error: Provisioning profile does not match bundle identifier: The provisioning profile specified in your build settings (“ColorKey Distribution”) has an AppID of “com.iAppsLLC.ColorKey” which does not match your bundle identifier “ com.iAppsLLC.ColorKey.MyKeyBoard”.
解决方法是：在build Settings 里有一项 Packaging项  里边有个Product Bundle Identifier  需要与plist文件里的Bundle Identifier 保持一致。最后修改完成以后clean一下充跑吧。如果证书，App ID ，以及描述文件没有设置错误，那就应该没有问题了。&lt;/p&gt;

&lt;p&gt;3.因为有些第三方库不支持bitcode。 关闭BItcode&lt;/p&gt;</content><summary type="html">开发随手记(二)</summary></entry></feed>
